<!DOCTYPE html><html><head><title>一文看懂浏览器原理</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="shortcut icon" type="image/x-icon" href="/image/logo.jpg"><link rel="stylesheet" href="/css/index.css"><meta name="keywords" content="浏览器,"><meta name="description" content="从一道面试题，散发出来的浏览器相关知识点"><script src="/js/jquery.min.js"></script><script src="/js/index.js"></script><script src="/js/fancybox.umd.js"></script><script src="/js/fancybox-images.js"></script><script src="/js/gitalk.min.js"></script><script src="/js/hljs.min.js"></script><script>hljs.highlightAll()</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="header"><div class="header-top" id="header-top"><div class="h-left"><a href="/"><img src="/image/loading.gif" data-original="/image/header.png" alt="Quiet"></a></div><div class="h-right"><ul><li><a href="/">HOME</a><span class="dot"></span></li><li><a href="/archives">ARCHIVE</a><span class="dot"></span></li><li><a href="/tags">TAGS</a><span class="dot"></span></li><li><a href="/about">ABOUT ME</a><span class="dot"></span></li></ul></div><div class="h-right-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)"/></svg></div></div></div><div class="sidebar"><div class="topo"><h2>Jesslyn wongkayan</h2></div><ul><li><a href="/">HOME</a></li><li><a href="/archives">ARCHIVE</a></li><li><a href="/tags">TAGS</a></li><li><a href="/about">ABOUT ME</a></li></ul><div class="my_foot"><a target="_blank" rel="noopener" href="https://github.com/Jesslynwong"><img src="/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题"></a></div></div><div class="shelter"></div><style>.shelter{background-color:#333;opacity:.5;cursor:pointer;display:none;position:fixed;left:0;top:0;right:0;bottom:0;z-index:1998}.sidebar{width:66%;height:100%;position:fixed;top:0;right:-100%;bottom:0;background:#fff;z-index:1999;text-align:center;box-shadow:-6px 0 20px rgba(98,94,94,.815)}.topo{width:100%;height:200px;background:url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;background-size:100% 100%;position:relative;display:flex;align-items:flex-end}.topo h2{color:#fff;z-index:1;position:relative;margin:0 0 10px 10px;font-size:1.2em;box-sizing:border-box}.topo:before{content:'';background-image:url(/image/pattern.png);background-repeat:repeat;height:100%;left:0;position:absolute;top:0;width:100%;z-index:1}.sidebar ul{width:100%;margin-top:50px}.sidebar ul li{height:50px;list-style:none;font-size:1.2em;text-align:right;margin-right:10px}.sidebar ul li a{display:grid;color:#5d606a;text-overflow:ellipsis;width:100%;text-decoration:none}.my_foot{width:100%;padding:10px;margin-bottom:10px;position:absolute;bottom:0}.my_foot a{text-decoration:none;margin-right:10px;display:inline-block}.my_foot a img{width:30px;height:30px}</style><script>$(function(){$(".h-right-close>svg").click(function(){$(".sidebar").animate({right:"0"},500),$(".shelter").fadeIn("slow")}),$(".shelter").click(function(e){$(".sidebar").animate({right:"-100%"},500),$(".shelter").fadeOut("slow")})})</script><div class="post"><div class="post-header-background post-header-img" style="background:url(https://api.ixiaowai.cn/gqapi/gqapi.php)"><div class="post-header-background-content"><ul class="post-header-tag"><li><a href="/tags/浏览器">浏览器</a></li></ul><h1>一文看懂浏览器原理</h1><div class="post-header-info"><div class="post-header-info-author"><svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20"><path d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1zm0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4zm0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6zm0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9zm0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z" p-id="2902" fill="#ffffff"></path></svg> <span class="post-header-info-author-text"><a target="_blank" rel="noopener" href="https://jesslynwong.github.io/about">Jesslyn</a></span><div class="post-header-info-author-categories"></div><p>2022-06-27 11:35:36</p></div></div></div></div><div class="post-content" id="content"><div id="article" class="post-content-info"><h2 id="浏览器进程介绍"><a href="#浏览器进程介绍" class="headerlink" title="浏览器进程介绍"></a>浏览器进程介绍</h2><p>​ 目前浏览器进程模式主要用的是 Process-per-site-instance，每个 site 公用一个进程。</p><blockquote><p>Process-per-site-instance: 打开相同的注册域名下使用的是同一个进程</p><p>Eg. a.Baidu.com &amp;&amp; b.Baidu.com</p></blockquote><h3 id="在Chrome中，主要的进程有4个："><a href="#在Chrome中，主要的进程有4个：" class="headerlink" title="在Chrome中，主要的进程有4个："></a>在Chrome中，主要的进程有4个：</h3><ul><li><p>浏览器进程 (Browser Process)：负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。</p></li><li><p>渲染进程 (Renderer Process)：负责一个Tab内的显示相关的工作，也称渲染引擎。</p></li><li><p>GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务</p></li><li><p>插件进程 (Plugin Process)：负责控制网页使用到的插件</p></li></ul><h3 id="四个进程大致-关系如下："><a href="#四个进程大致-关系如下：" class="headerlink" title="四个进程大致 关系如下："></a>四个进程大致 关系如下：</h3><p>​ 首先 浏览器进程会处理 URL，然后相对应的地址发请求，获取这个请求所对应的资源，也就是HTML CSS JS。</p><p>​ 然后，把资源给渲染进程，渲染进程则负责 将资源解析计算得到图像帧。</p><p>​ 如果解析的过程中，遇到需要请求的资源渲染进程，会通知浏览器进程进行加载，如果需要插件进程来加载插件资源的话，执行插件代码。</p><p>​ 最后，把图像帧给 GPU 进程，GPU进程，再将其图像帧渲染出来。</p><h2 id="输入-URL-后按下回车之后会发生什么？"><a href="#输入-URL-后按下回车之后会发生什么？" class="headerlink" title="输入 URL 后按下回车之后会发生什么？"></a>输入 URL 后按下回车之后会发生什么？</h2><p>​ 浏览器进程主要分为 UI 线程、网络线程、存储线程。</p><p>​ 输入 URL 时，UI 线程控制浏览器按钮和输入框。此时 UI 线程会判断这个是否 URL，如果是的话开始请求 URL，否则 跳转至默认搜索引擎进行搜索。</p><p>​ 按下回车之后，UI 线程图标变为 loading 状态，然后网络进程进行网络连接（这里涉及到 DNS 寻址，建立 TCP 连接等网络内容），网络进程通过请求报文状态来判断获取资源方式（涉及浏览器缓存概念）。</p><p>​ 获取响应之后根据 content-type 来判断响应的媒体类型（MIME TYPE），媒体类型是 HTML 文件，则把对应文件交给渲染进程处理，如果是文件类型则会把数据给下载管理器</p><p>​ 网络进程确认可以导航到 URL 的时候，会告知 UI 进程已经准备好，UI 进程找到一个渲染进程进行网页渲染。这一步在开始 UI进程导航的时候已经开始寻找这个渲染进程进行先等候。当拿到数据的时候就能够直接进行他的工作。但是如果遇到重定向，则可能会出现准备好的渲染进程不可用的情况，因为同 site 共用一个进程。这时可能会出现重启渲染进程。</p><p>​ 这个时候，数据和渲染进程准备好了，浏览器进程会向渲染进程发送消息， 确认导航，然后浏览器进程将准备好的这些数据发送给渲染进程，渲染进程收到数据之后，又告诉浏览器进程已经提交了，这个时候页面就开始加载了，此时的 UI 线程会把导航栏进行更新，也就是会把前面的 loading 变为一个锁。并且把访问历史列表进行更新（涉及了路由的概念）</p><p>​ 渲染进程开始加载资源，渲染网页（涉及了网页渲染原理概念）。渲染完了之后，UI线程会停止加载 loading 图标。</p><h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><h3 id="1-构建-DOM（网络线程、主线程）："><a href="#1-构建-DOM（网络线程、主线程）：" class="headerlink" title="1.  构建 DOM（网络线程、主线程）："></a>1. 构建 DOM（网络线程、主线程）：</h3><p>​ 构建的过程中如果遇到 src 、link、js 脚本等，这些需要加载资源的，则会一一发送请求。实际上浏览器也会进行预加载，让浏览器进程的网络线程下载。</p><h3 id="2-解析资源："><a href="#2-解析资源：" class="headerlink" title="2. 解析资源："></a>2. 解析资源：</h3><p>​ 在这个过程中如果遇到 script 标签停止解析，因为 script 有可能会使得 DOM 结构发生改变。（这个时候可以设置 defer 或者 async 属性让浏览器异步加载执行 js 代码，不会阻塞渲染）</p><h3 id="3-构建-CSSOM-树（主线程）"><a href="#3-构建-CSSOM-树（主线程）" class="headerlink" title="3. 构建 CSSOM 树（主线程）"></a>3. 构建 CSSOM 树（主线程）</h3><p>​ 主线程遇到 style 或者 link 的 CSS 资源的时候，会解析 CSS 代码，计算 DOM 的样式。</p><p>​ 实际上解析 HTML 和解析 CSS 是并行的</p><h3 id="4-形成-渲染树（主线程）"><a href="#4-形成-渲染树（主线程）" class="headerlink" title="4. 形成 渲染树（主线程）"></a>4. 形成 渲染树（主线程）</h3><p>​ DOM 树和 CSSOM 生成之后，就可以进行布局，把 CSSOM 和 DOM 树关联起来，计算每个 DOM 大小等布局信息，此时两者结合就形成了渲染树（render tree）。遍历的时候会跳过隐藏的元素，但不会跳过伪元素</p><h3 id="5-绘制渲染树（主线程）"><a href="#5-绘制渲染树（主线程）" class="headerlink" title="5. 绘制渲染树（主线程）"></a>5. 绘制渲染树（主线程）</h3><p>​ 浏览器会根据计算出来的渲染树进行遍历，形成绘画记录</p><h3 id="6-合成光栅化（合成线程、主线程、光栅化线程）"><a href="#6-合成光栅化（合成线程、主线程、光栅化线程）" class="headerlink" title="6. 合成光栅化（合成线程、主线程、光栅化线程）"></a>6. 合成光栅化（合成线程、主线程、光栅化线程）</h3><p>​ 这个时候需要展示到屏幕上只需要光栅化即可</p><blockquote><p>光栅化：把绘画信息转化为像素</p></blockquote><p>​ Chrome 的光栅化做了分层，最后在合成线程中合成新的帧进行展示。</p><h2 id="合成技术"><a href="#合成技术" class="headerlink" title="合成技术"></a>合成技术</h2><p>​ 合成技术主要是对不同的元素进行分层，主线程需要遍历渲染树来创建层次树，在层次树上分了不同层。对于加了 will-change 的 CSS 属性会在同一层上。</p><p>​ 合成线程会对每层进行光栅化。有的层大小较大，合成线程会把改层切成小图块（绘画四边形），分别发给光栅化进程，这个时候光栅化进程会把像素信息存在 GPU 进程内存中。（这里可以理解为，合成进程干轻活，遇到重活，就分成轻活给光栅化进程干）</p><p>​ 合成线程在光栅化线程赋予了不同的优先等级，在视口或者视口附近的地方优先级较高，会先被光栅化，完了之后，合成线程会形成合成帧。此时把合成帧发送到 GPU 进程处理，渲染到页面上。</p><h2 id="浏览器事件处理"><a href="#浏览器事件处理" class="headerlink" title="浏览器事件处理"></a>浏览器事件处理</h2><p>​ 当触发事件的时候，浏览器进程接收到事件信息（具体位置和触发类型），把事件信息传送给渲染进程，渲染进程遍历渲染树找到对象，运行绑定的监听函数。实际上需要分以下两个步骤：查找事件发生位置、处理事件</p><h3 id="查找事件对象"><a href="#查找事件对象" class="headerlink" title="查找事件对象"></a>查找事件对象</h3><p>合成器线程是第一个收到事件消息的，合成器判断事件发生的地方不在非快速滚动区域之后，合成器线程会向主线程发送事件信息，主线程进行命中测试找到事件发生对应的目标元素。 命中测试主要是遍历在布局形成的绘画记录（渲染过程第5步）中来找到事件发生坐标上的元素对象。</p><h3 id="合成器线程接收事件"><a href="#合成器线程接收事件" class="headerlink" title="合成器线程接收事件"></a>合成器线程接收事件</h3><p>​ 当区域内没有绑定事件的时候，合成器线程可以独立于主线程之外，直接利用已经光栅化的层来形成新的帧。但是当区域内绑定了事件（非快速滚动区域），需要等主线程处理事件。此时，事件处理有可能会导致重绘或者重排。</p><p>​ 当把事件绑定在 body 上的时候，出现整个 body 都是非快速滚动区域，此时，页面内没有绑定事件的区域不能让合成器独立合成帧了。</p><p>​ 那要是非要这样处理才能满足业务需求呢？那就在 addEventListener 第三个参数处，改为 true ，那么 passive 会告诉浏览器你既要绑定事件，又要让组合器线程直接跳过主线程的事件处理直接合成创建组合帧。（？？？？why）</p><h3 id="浏览器对事件的优化"><a href="#浏览器对事件的优化" class="headerlink" title="浏览器对事件的优化"></a>浏览器对事件的优化</h3><ul><li><p>一般的浏览器的刷新率为60Hz，也就是说，1秒钟就会刷新60次，也就是说，大概每过<code>16.6ms</code>浏览器会渲染一帧画面</p></li><li><p>所以我们一般希望动画间隔时间为16.6ms</p><ul><li>快了：更快一点也是一样的效果为什么要消耗这个资源去做无意义的事</li><li>慢了：出现掉帧现象</li></ul></li></ul><blockquote><p>RAF : 请求动画帧。</p><ol><li>会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li><li>在隐藏或不可见的元素中，<code>requestAnimationFrame</code>将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量</li></ol></blockquote><p>RAF要求浏览器在下次重绘之前调用指定的回调函数更新动画</p><p>​ 用 JS 实现一般使用 setTimeout 和 setInterval 来进行循环不稳，可能出现掉帧或者出现卡顿情况。因为setTimeout、setInterval宏任务，这里涉及到浏览器的 Event loop</p><p>​ <code>requestAniamationFrame</code>的执行步伐是跟着系统走的（不受其他任务的影响），如果系统的绘制频率是60Hz，那么回调函数就每16.7ms被执行一次–这样不会引起丢帧（时间执行快了）现象也不会卡顿（时间执行慢了）。当页面处于不可见或不可用状态时，浏览器就会停止动画，这意味着更少的CPU和更少的内存消耗。</p><blockquote><p>丢帧： 最上面的一行代表大多数监视器上显示的16.7ms显示频率，最下面的一行代表10ms的典型setTimeout。由于在显示刷新间隔之前发生了另一个绘制请求，因此无法绘制每三个绘制（用红色箭头指示）。</p></blockquote><p><img src="/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Jesslynwong/Pics@main/20221028144603.png"></p><h2 id="兼容性："><a href="#兼容性：" class="headerlink" title="兼容性："></a>兼容性：</h2><p>由于requestAnimationFrame目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀，如果不支持requestAnimationFrame和cancelAnimationFrame，则使用setTimeout和clearTimeout。兼容性封装：</p><pre><code class="js">window.requestAnimationFrame = window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function (callback) &#123;
    //为了使setTimteout的尽可能的接近每秒60帧的效果
    window.setTimeout(callback, 1000 / 60)
  &#125;

window.cancelAnimationFrame = window.cancelAnimationFrame ||
  Window.webkitCancelAnimationFrame ||
  window.mozCancelAnimationFrame ||
  window.msCancelAnimationFrame ||
  function (id) &#123;
    window.clearTimeout(id)
  &#125;;
</code></pre><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022633988">https://segmentfault.com/a/1190000022633988</a><br><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B</a></p></div><div id="gitalk-container"></div></div><script>Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});</script><style>#noneimg img{display:none;z-index:9999;min-width:0;max-width:90%;max-height:80%;border-radius:0;position:fixed;box-shadow:0 0 0 #c3c3c300!important;left:0;top:0;right:0;bottom:0;margin:auto!important}@media screen and (max-width:600px){#noneimg img{max-width:88%}}</style><div class="post-paging"><a href="/2022/06/28/browserCacheSecureStorage/"><div class="post-paging-last"><span>上一篇</span><p>浏览器缓存、存储、安全及防范</p></div></a></div></div><div class="footer"><div class="Copyright">©2022 By Jesslyn wongkayan.</div><div class="contact"><a target="_blank" rel="noopener" href="https://github.com/Jesslynwong"><img src="/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题"></a></div></div><script src="/js/gotop.js"></script><style>@media screen and (min-width:600px){.goTop>span{display:flex;align-items:center;justify-content:center;border-radius:10px;width:40px;height:40px;cursor:pointer;opacity:.8;background:rgba(18,24,58,.06);text-align:center;transition:border .5s;border:1px solid rgba(18,24,58,.06);-moz-transition:border .5s;-webkit-transition:border .5s;-o-transition:border .5s}.goTop>span:hover{border:1px solid #6680b3}.goTop{position:fixed;right:30px;bottom:80px}.goTop>span>svg{width:20px;height:20px;opacity:.7}}@media screen and (max-width:600px){.goTop{display:none}}</style><div class="goTop" id="js-go_top"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g><path d="M13 12v8h-2v-8H4l8-8 8 8z"></path></g></svg></span></div><script>$("#js-go_top").gotoTop({offset:500,speed:300,animationShow:{transform:"translate(0,0)",transition:"transform .5s ease-in-out"},animationHide:{transform:"translate(100px,0)",transition:"transform .5s ease-in-out"}})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4b5fe1472f22fadsfs";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const data = '{"clientID":"8c7e2048c78b8bc2a849","clientSecret":"011c69973020c48e4bc0f897b4f7d54f04ea84a5","repo":"jesslynwong.github.io","owner":"Jesslynwong","admin":"Jesslynwong"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('true')){
            gitalk.render('gitalk-container')
        }</script><script>console.log("\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n","color: #fadfa3; background: #030307; padding:5px 0;","background: #fadfa3; padding:5px 0;")</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var t,r=0;r<c.length;r++)0<=(t=(t=c[r]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n()},e.src=i}()}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this)</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script></body></html>